---
layout: post
title: ARM Toolchain 
category: programming
---

We will need the ARM-gcc-toolchain (download from repos ) `arm-none-eabi-gcc`

more:

```sh
$ ls arm-none-eabi-*
arm-none-eabi-addr2line*  arm-none-eabi-gcc-ar*         arm-none-eabi-ld.gold*
arm-none-eabi-ar*         arm-none-eabi-gcc-nm*         arm-none-eabi-nm*
arm-none-eabi-as*         arm-none-eabi-gcc-ranlib*     arm-none-eabi-objcopy*
arm-none-eabi-c++*        arm-none-eabi-gcov*           arm-none-eabi-objdump*
arm-none-eabi-c++filt*    arm-none-eabi-gcov-dump*      arm-none-eabi-ranlib*
arm-none-eabi-cpp*        arm-none-eabi-gcov-tool*      arm-none-eabi-readelf*
arm-none-eabi-dwp*        arm-none-eabi-gdb*            arm-none-eabi-size*
arm-none-eabi-elfedit*    arm-none-eabi-gdb-add-index*  arm-none-eabi-strings*
arm-none-eabi-g++*        arm-none-eabi-gprof*          arm-none-eabi-strip*
arm-none-eabi-gcc*        arm-none-eabi-ld*
arm-none-eabi-gcc-8.2.0*  arm-none-eabi-ld.bfd*

```
 Unix cross compilers are loosely named using a convention of the form **arch[-vendor][-os]-abi**.
The **arch** refers to the target architecture, which in our case is ARM. 
The **vendor** nominally refers to the toolchain supplier.
The **os** refers to the target operating system, if any, and is used to decide which libraries (e.g. newlib, glibc, crt0, etc.) to link and which syscall conventions to employ. 
The **abi** specifies which application binary interface convention is being employed, which ensures that binaries generated by different tools can interoperate.


`arm-none-eabi` is the toolchain we use in this class. This toolchain targets the ARM architecture, has no vendor, does not target an operating system (i.e. targets a “bare metal” system), and complies with the ARM EABI.

EABI = embedded ABI

Binary compatibility

 ABI. This details how arguments are passed to, and received from functions.

---
source:  Application Binary Interface for the ARM® Architecture

**The C library ABI for the ARM architecture**
The C library ABI is described in the document C Library ABI for the ARM Architecture[CLIBABI].
The C library ABI specifies:
    - A binary interface to the C89 run-time library that allows a C-library-using function built by one tool chain to use the C library implementation provided by another.
    - Constraints on language library headers necessary to allow tool chain X to use its own headers, or tool chain Y’s headers, when building an object that must interface to tool chain Y's run-time library.

Compliance with this specification is a header-by-header quality of implementation issue. Compliance is not required in order to claim compliance to this base standard ABI for the ARM architecture.

Libraries of relocatable ELF files must be formatted as Unix-style ar format linkable libraries


**The base platform ABI for the ARM architecture**: 
The base platform ABI for the ARM architectureThe base platform ABI is described in the document Base Platform ABI for the ARM Architecture [BPABI].
The base platform ABI specifies:
    - The content and format of ELF-based executable files suitable for post-processing to platform-specific binary formats appropriate to the families of execution environment supported by this ABI (Figure 1). 
    - The division of responsibility between static linkers generating fully symbolic executable ELF files and post-linkers generating less symbolic, platform-specific executable files.
    - The static linking functionality needed to generate a generic executable file – the functionality needed to encompass the platform families supported by this ABI

---
source: wikipedia
An embedded-application binary interface (EABI) specifies standard conventions for file formats, data types, register usage, stack frame organization, and function parameter passing of an embedded software program, for use with an embedded operating system. 


----
source: [ARM Cortex-A Series Programmer’s Guide for ARMv8-A](http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/CHDGIGJG.html)


The Application Binary Interface (ABI) for the ARM Architecture specifies fundamental rules to which all executable native code modules must adhere so that they can work correctly together. These fundamental rules are supplemented by additional rules for specific programming languages (for example, C++). Individual operating systems or execution environments (for example, Linux) may specify additional rules to meet their own specific requirements, beyond those rules specified by the ARM ABI.

There are a number of components to the ABI for the AArch64 architecture:

Executable and Linkable Format (ELF)

    ELF for the ARM 64-bit Architecture (AArch64) specifies the object and executable format.
Procedure Call Standard (PCS)

    Procedure Call Standard for the ARM 64-bit Architecture (AArch64) ABI release specifies how subroutines can be separately written, compiled and assembled to work together. It specifies the contract between a calling routine and a callee, or between a routine and its execution environment, for example, the obligations when calling a routine or stack layout.
DWARF

    This is a widely used standardized debugging data format. AArch64 DWARF is based on DWARF 3.0, but with some additional rules. See DWARF for the ARM 64-bit Architecture (AArch64) for details. 
C and C++ libraries

    ARM Compiler ARM C and C++ Libraries and Floating-Point Support User Guide describes the ARM C and C++ libraries.
C++ ABI

    C++ Application Binary Interface Standard for the ARM 64-bit Architecture describes the generic C++ ABI.


---

## steps:
- Install st-util
- Download [STM32CubeF7](https://www.st.com/en/embedded-software/stm32cubef7.html#getsoftware-scroll)
- Install Openocd 


Interesting links
- [CMSIS](https://www.arm.com/why-arm/technologies/cmsis)


TO read:
makefile
STMCube has everything I need for development --> need to put it on a makefile
linker 




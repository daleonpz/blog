---
layout: post
title: Docker + toolchains
category: programming
---

I heard about Docker and container technology last year, but I never really used it, until I notice that toolchains, depending on the OS,  are easy or hard to set-up. 
In that moment, I remember the main characteristic of container technology: **a piece of software with all its dependencies**. 

Docker is a tool designed to create, deploy and run an application by using containers, and a container is a unit of software that includes all its dependencies so the application runs regardless the installed OS, because all that application might need is already in the container. 

## Docker Terms
Let's define some terms so it will be easier to explain later other concepts.

- **Docker Image**: Binary file that includes everything needed to run an application.
- **Container**: Runtime instance of the image. Your application runs on a container.
- **Dockerfile**: File with commands to build a Docker image. 

## Building a Docker Image 
First I need a Dockerfile, in which I should specify the dependencies of my application and  configuration of the image (setting the path for example). 
Since I'm working with cortex-M microcontrollers, I will need basically the following:

- GNU ARM embedded toolchain [link](https://developer.arm.com/open-source/gnu-toolchain/gnu-rm)
- The toolchain runs on a OS, i'll use apline linux
-  `make` to compile my applications 

My Dockerfile is as follows:

```text
FROM frolvlad/alpine-glibc:alpine-3.9_glibc-2.29 

# Set up a tools dev directory
WORKDIR /home/dev

# Packages that will be needed once
RUN apk --update --no-cache add --virtual build-dependencies  \
    w3m \
    wget \
    openssl \
    ca-certificates \
    bzip2-dev \
    tar

# Install make
RUN apk --update --no-cache add make

# Install GNU ARM toolchain
RUN wget https://developer.arm.com/-/media/Files/downloads/gnu-rm/8-2018q4/gcc-arm-none-eabi-8-2018-q4-major-linux.tar.bz2 \
    && tar xvf gcc-arm-none-eabi-8-2018-q4-major-linux.tar.bz2 \
    &&  rm gcc-arm-none-eabi-8-2018-q4-major-linux.tar.bz2 

RUN apk del build-dependencies

# Set up the compiler path
ENV PATH="/home/dev/gcc-arm-none-eabi-8-2018-q4-major/bin:${PATH}"
```

Building a Docker image is super easy, just run `docker build -t IMAGE_TAG .`. In my case

```sh
$ docker build -t daniel/test .
```

To verify my image was built, I used `docker image ls`.

```sh
$  docker image ls
REPOSITORY              TAG                     IMAGE ID            CREATED             SIZE
daniel/test             latest                  71b2c630bd2f        11 minutes ago      507MB
frolvlad/alpine-glibc   alpine-3.9_glibc-2.29   4e5eb981daf8        5 weeks ago         12.2MB
```

There are two images because my image `daniel/test` depends on the base linux image `frolvlad/alpine-glibc`. 

**Note**: if you want to know more about the Alpine linux package manager (apk) check this [link](https://github.com/gliderlabs/docker-alpine/blob/master/docs/usage.md) 

## Running an application

![Docker environment](/images/posts/docker_mount1.png)

to run the executable

```sh
docker run -v $(pwd):/usr/src/myapp --name TestContainer -w /usr/src/myapp gcc ./hello
```

![Docker mount](/images/posts/docker_mount2.png))

my working directory `$(pwd)` is mounted on `/usr/src/myapp` 
 The -w /usr/src/myapp sets the working directory of the container to /usr/src/myapp where any commands will be executed. 


`--name` is to name the container, it's useful for debugging or to recognize containers


## Pulling an image


```c
$ docker search gcc
```

Using filers, it's better to use official packages when possible because a good unofficial image will have a decent set of instructions about its use and how it was built. Unfortunately, most donâ€™t have any information and you can waste a substantial amount of time trawling through the repositories looking for a suitable image.

```sh
$ docker search --filter "is-official=true" gcc
```

pull an image

```sh
$ docker pull gcc
```

![Dockerhub workflow](/images/posts/docker_workflow.png)

check for images

```sh
$ docker image ls -a
```


running `gcc -v` in the  container

```sh
docker run gcc gcc -v
```


compiling a file

```sh
$  docker run -v $(pwd):/usr/src/myapp --name TestContainerCompile -w /usr/src/myapp gcc gcc -o hello main.c
```

my working directory `$(pwd)` is mounted on `/usr/src/myapp` 
 The -w /usr/src/myapp sets the working directory of the container to /usr/src/myapp where any commands will be executed. 


`--name` is to name the container, it's useful for debugging or to recognize containers

to run the executable

```sh
docker run -v $(pwd):/usr/src/myapp --name TestContainer -w /usr/src/myapp gcc ./hello
```



# Clean up

show running containers 

```sh
$  docker container ls -a
```

to delete  use the ID, because is unique

```sh
$docker container rm CONTAINER ID
```


Or you can automatically delete the container after it's done with `--rm`

```sh
$ docker run --rm -v $(pwd):/usr/src/myapp -w /usr/src/myapp gcc make
```


And to delete the image
```sh
docker rmi gcc
```
